# 目录
- 命名规范
- 结构化规范
- 注释规范
- 编码规范
- CSS 规范

## 1. 注释规范：

- 不用的代码删掉，不要注释
- 功能模块，需要注明详细用途,文档
- 业务函数，需要注明详细的业务

        /*
        @autor:
        @busness
        */

- 功能函数：简述用途

        /*
        @function
        @param
        @return
        */


> 开发vscode插件（待完善）

## 2. layout布局，项目结构规范

为保证项目结构清晰， 布局框架通用性， 非通用布局放在 `layout/busness/*.vue` (busness: 业务模块名，即业务对应页面所在文件夹， items 存放所有布局内部组件

```
//项目结构
|--src/views/envManage/devices.vue
|--src/views/layout/envManage/EnvLayout.vue
```

**命名保持统一，双单词拼接而成，避免单词命名，需和 h5 规范保持一致** `busness+layout`, 
```
eg：
MainLayout
BaseLayout
envLayout
envHeader
deviceAside
```

## 3. 组件规范：

- 组件必须高度`集成`，`模块化`，`解耦合`
- 高度`通用性`

命名遵循 PascalCase 约定

公用组件以 Abcd (公司名缩写简称) 开头，如（AbcdDatePicker,AbcdTable）

页面内部组件以组件模块名简写为开头，Item 为结尾，如（StaffBenchToChargeItem，StaffBenchAppNotArrItem）

使用遵循 kebab-case 约定

在页面中使用组件需要前后闭合，并以短线分隔，如（<abcd-date-picker></abcd-date-picker>，<abcd-table></abcd-table>）
导入及注册组件时，遵循 PascalCase 约定

> 关于组件封装

1. 底层原生封装
2. 框架二次封装

**注：**

- 二次封装，意味着组件变动的代价变大，灵活性变小，通用性变差
- 底层封装意味着更复杂的工作量， 且代码，功能未必有社区框架优质， 另一方面，则更依赖优质的文档，否则对于后期维护，及人员变动来讲，自有组件有等于无

**解决上述方案：**

- 通用功能性组件， 使用框架原生组件最好， 文档，社区，博客，所有资料互通，可快速解决问题，人员变动维护代价不大
- 业务型通用组件， 需要高度封装，详细的文档，避免多次实现。
- 框架组件功能拓展： 
1.现框架缺失的常用功能组件需要封装，如：级联选择框，级联输入框
2.现框架已有组件功能进行拓展，需要二次封装现有组件
- 二次封装拓展组件和框架原生组件仅仅应该区别于功能，而表现形式需要一致，即通过公共样式控制表现形式. 如： el-table二次封装

**非通用型组件，放在模板里：../template/*.vue**

> 组件，插件封装文档(待完善)

- dev:  doc需要对应样例， api,  效果图
- pro:  doc不进行打包编译

## 4. 静态资源

- 为了便于图片管理维护

a.小图标图片（指类字体图标） `./icon`

b.通用图标： 根据功能命名 `./img`

c.业务型图片放在 `./img/busness` 下

d.不要通过大小写区分图片

- 静态json 数据放在 `assert/data` 下

**避免多种资源混合在一起，避免所有图片堆在一个目录下，避免通用图标，图片和业务图片混杂在一起**

## 样式

- 公共样式抽离 命名需要统一规范

- 图标字体样式抽离， 所有项目统一命名方式，命名规范：

- 样式模块化

在 scoped 样式中，类选择器比元素选择器更好，因为大量使用元素选择器是很慢的。

## api 规范

- 公共模块抽离： 登录控制，个人信息，权限控制， 环境控制...


## 其他
避免 this.$parent

调试信息 console.log() debugger 使用完及时删除

除了三目运算，if,else 等禁止简写

## 相关
[vue 开发规范](https://juejin.im/post/5b67e49551882508603d1431)
